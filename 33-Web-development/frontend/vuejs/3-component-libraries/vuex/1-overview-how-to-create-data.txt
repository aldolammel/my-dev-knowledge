

VUEX: HOW TO CREATE DATA

    STEP 0: WORKFLOW) Overview of the VueX workflow:
        /33-Web-development/frontend/vuejs/3-component-libraries/vuex/one-way-data-flow.png


    STEP 1: STATE) Declare the state property and its initial value in /store/index.js (frontend db):

        E.g.
            import { createStore } from 'vuex'
            export default createStore({
                // State means data for VueX:
                state: {
                    products = [],  // this is the declaration of 'products' state/data!
                    cart = [],      // this is another declaration.
                },
                actions: {}
                mutations: {}
                modules: {}
            }


    STEP 2: VIEW AND DISPATCH) In a component .vue file or in the app .vue main file,
        the component (view) need to be linked with its state and dispatch:

        >> VIEW:
            At first, let's allow the view to display the state/data:

            >> When the view is a component .vue file:
                export default {
                    name: 'Home',  // component name
                    data() {
                        ...
                    }
                    // Lifecycle hook:
                    computed: {
                        // Computed properties
                        products() {
                            return this.$store.state.products;  // this '.products' is a state property (data)!
                        },
                        cart() {
                            return this.$store.state.cart;  // this '.cart' is a state property (data)!
                        }
                    },
                }

            >> When the view is an App .vue file:
                XXXXXXXXXXXXXX NO SURE IF IT CAN HAPPENING xXXXXXXXXXXXXXXXXXXXX

        >> DISPATCH:
            In the view where the data is shown, address/dispatch the action to update
            a specific state property (data):
            
            >> When the data must be loaded automatically, set the dispatch in the App .vue file:

                export default {
                    // Lifecycle hook:
                    created() {
                        this.$store.dispatch('loadProducts');  // 'loadProducts' is the action to call.
                    }
                }

                >> More about Lifecycle-hooks:
                    /33-Web-development/frontend/vuejs/2-vue-knowledge/lifecycle-hooks.txt

            >> When the data must be loaded just after some user directly interaction,
                set the dispatch in a component .vue file:

                >> On <template> layer:

                    <button
                        type="button"
                        @click="btAddToCart(product)"  <!-- considering 'product' comes from a for-loop -->
                    >
                        Add to Cart
                    </button>

                >> On <script> layer:

                    export default {
                        // Lifecycle hook:
                        ...
                        // Methods/functions:
                        methods: {
                            // Addressing/Dispatching the action responsable for update something:
                            btAddToCart(product) {
                                // This function is called if a user click over the 'Add to Cart' button.
                                this.$store.dispatch('addToCart');  // 'addToCart' is the action to call.
                            }
                        }
                    }


    STEP 3: ACTION) Back to the /store/index.js, create an action that will execute a
        mutation (next step) to update a specific state/data when called:

        >> When the data must be loaded directly from an API/JSON:
            
            >> Using FetchAPI (native of JavaScript):
                /33-Web-development/frontend/javascript/examples/fetch-api-on-vuejs/vuex_action_using_fetchApi.js

            >> Using Axios:
                /xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

        >> When the data is already in a state, but can be updated by another action:
            
            export default createStore({
                //...
                actions: {
                    //...,
                    addToCart({ commit }, product) {  // 'addToCart' is the action!
                        // This function call the mutation responsable to update the shopping cart.
                        commit('updateCart', product);  // 'updateCart' is the mutation to call!
                    },
                },
                //...
            })
    

    STEP 4: MUTATION) Finally and still in /store/index.js, create the mutation that will execute
        the action over a state. In other words, it adds/updates a specific state/data when activated:

        Both mutation examples used on this overview about VueX:

            mutations: {
                updateProducts(state, products) {  // 'updateProducts' is a mutation!
                    state.products = products;  // 'state.products' is the state to be updated.
                },
                updateCart(state, product) {  // 'updateCart' is a mutation!
                    state.cart.push(product);  // adding a product to the cart state property;
                }
            },


TESTING IT:

    X) Checking whether the data is been sent to the browser, using the "Vue DevTool":
        - Open the Browser Develop Tool;
        - Go to the Vue tab;
        - Select the component where the data is;
        - If everything's fine, you're seeing the 'computed' with its data (array, probably)
            somewhere on the dev panel;

