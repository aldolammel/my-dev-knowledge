

EXTENDING THE USER FEATURES WITH PROFILE:

    >> Let's create another model/table in order to isolate extra data associate with each user,
        creating a UserProfile class;

    >> This approach make easier to management user-data that might change drastically if a special
        setting is activated, for example, from personnal account to business one where the data
        associated with the user probably change a lot;


    1) Very basic to use Django built-in user features:
        /33-Web-development/general/django/3-1-backend-models-database/3-users/0-users-setup.txt
        /33-Web-development/general/django/3-1-backend-models-database/3-users/extending-users-basic.txt



    2) In 'accounts' sub-app, open the 'models.py' file:

        from django.db import models
        from django.contrib.auth.models import AbstractUser

        # CONSTANTS:
        VAL_PROFILE_1 = '1'
        VAL_PROFILE_2 = '2'
        VAL_SEX_1 = 'f'
        VAL_SEX_2 = 'm'
        VAL_SEX_3 = 'i'
        REL_PROFILE_1 = 'profile_1'
        REL_PROFILE_2 = 'profile_2'
        CHOICES_PROFILE_TYPE = (
            (VAL_PROFILE_1, 'personnal'),
            (VAL_PROFILE_2, 'business'),
        )
        CHOICES_SEX = (
            (VAL_SEX_1, 'female'),
            (VAL_SEX_2, 'male'),
            (VAL_SEX_3, 'intersex'),
        )


        class User(AbstractUser):
            profile_type = models.CharField(
                max_length=15,
                choices=CHOICES_PROFILE_TYPE,
                default=VAL_PROFILE_1,  # Needed, e.g. when Django superuser is created.
                blank=False,
            )
            first_name = models.CharField(
                max_length=150,
                blank=True,
            )
            last_name = models.CharField(
                max_length=150,
                blank=True,
            )
            email = models.EmailField(
                blank=True,
            )
            sex = models.CharField(
                max_length=20,
                choices=CHOICES_SEX,
                null=True,
                blank=True,
            )
            birthdate = models.DateField(
                null=True,
                blank=True,
            )
            is_notified_by_email = models.BooleanField(
                default=True,
            )
            # created_at = 'date_joined' from AbstractUser
            updated_at = models.DateTimeField(
                auto_now=True,
                blank=True,
            )

            class Meta:
                db_table = 'auth_user'
                ordering = ['username',]
                verbose_name = 'User'
                verbose_name_plural = 'Users'

            def __str__(self):
                return self.username


        class UserProfileOne(models.Model):
            id = models.BigAutoField(
                primary_key=True,
                unique=True,
                editable=False,
            )
            user = models.OneToOneField(
                User,
                on_delete=models.CASCADE,  # Tells Django to del the UserProfileOne if the User is deleted.
                related_name=REL_PROFILE_1,
            )
            updated_at = models.DateTimeField(
                auto_now=True,
                blank=True,
            )
            # All other fields exclusive from UserProfileOne!

            class Meta:
                db_table = 'user_profile_one'
                ordering = ['user']
                verbose_name = 'Personnal Profile'
                verbose_name_plural = 'Personnal Profiles'

            def __str__(self):
                if self.user:
                    return self.user.username
                return 'ERROR: NO PROFILE!'
            
            
        class UserProfileTwo(models.Model):
            id = models.BigAutoField(
                primary_key=True,
                unique=True,
                editable=False,
            )
            user = models.OneToOneField(
                User,
                on_delete=models.CASCADE,  # Tells Django to del the UserProfileOne if the User is deleted.
                related_name=REL_PROFILE_1,
            )
            updated_at = models.DateTimeField(
                auto_now=True,
                blank=True,
            )
            # All other fields exclusive from UserProfileTwo!

            class Meta:
                db_table = 'user_profile_two'
                ordering = ['user']
                verbose_name = 'Business Profile'
                verbose_name_plural = 'Business Profiles'

            def __str__(self):
                if self.user:
                    return self.user.username
                return 'ERROR: NO PROFILE!'

        

    3) Create the signal to create a linked UserProfile entry automatically when a new user is
        created via front-end or Django CMS:

        /33-Web-development/general/django/7-middlewares-and-signals/signals-user-extended.txt



    
    4) Open the accounts 'admin.py' file, and:

        from django.contrib import admin
        from django.contrib.auth.admin import UserAdmin
        from django.utils.html import format_html
        from django.urls import reverse
        from .models import (
            User,
            UserProfileOne,
            UserProfileTwo,
            VAL_PROFILE_1,
            VAL_PROFILE_2,
            REL_PROFILE_1,
            REL_PROFILE_2,
        )


        class UserCMS(UserAdmin):
            '''Defining how the User Model class will exclusivily be shown on the CMS.'''

            list_display = (
                'username',
                'email',
                'last_login',
            )
            fieldsets = (
                (
                    None,
                    {
                        'fields': (
                            'username',
                            'password',
                        )
                    },
                ),
                (
                    'Personal info',
                    {
                        'fields': (
                            'first_name',
                            'last_name',
                            'email',
                            'sex',
                            'birthdate',
                            'profile_link',  # Adding the UserProfile link in the User Detail-view!
                        )
                    },
                ),
                (
                    'Permissions',
                    {
                        'fields': (
                            'is_active',
                            'is_notified_by_email',
                            'is_staff',
                            'is_superuser',
                            'groups',
                            'user_permissions',
                        )
                    },
                ),
                (
                    'Important dates',
                    {
                        'fields': (
                            'date_joined',
                            'last_login',
                            'updated_at',
                        )
                    },
                ),
            )
            list_filter = (
                'is_active',
                'sex',
                'is_notified_by_email',
                'is_staff',
                'is_superuser',
            )
            search_fields = [
                'username',
                'first_name',
                'last_name',
                'email',
            ]
            readonly_fields = (
                'username',
                'date_joined',
                'last_login',
                'updated_at',
            )

            # Create a hyperlink to the associated UserProfile to be used on the list-view and detail-view:
            def profile_link(self, obj):
                if obj.profile_type == VAL_PROFILE_1 and hasattr(obj, REL_PROFILE_1):
                    url = reverse(
                        # Automatic admin-view creation structure: 'admin:app_label_modelname_change':
                        'admin:accounts_userprofileone_change',
                        args=[getattr(obj, REL_PROFILE_1).id],
                    )
                    return format_html(
                        "<a href='{}'>{} ({})</a>", url, 'personnal', 'more details'
                    )
                elif obj.profile_type == VAL_PROFILE_2 and hasattr(obj, REL_PROFILE_2):
                    url = reverse(
                        'admin:accounts_userprofiletwo_change',
                        args=[getattr(obj, REL_PROFILE_2).id],
                    )
                    return format_html(
                        "<a href='{}'>{} ({})</a>", url, 'business', 'more details'
                    )
                return 'ERROR: NO PROFILE!'

            profile_link.short_description = 'User Profile'

            # Make profile_link readonly in the detail-view:
            def get_readonly_fields(self, request, obj=None):
                return super().get_readonly_fields(request, obj) + ('profile_link',)  # type: ignore


        class UserProfileOneCMS(admin.ModelAdmin):
            '''Defining how the UserProfileOne Model class will exclusivily be shown on the CMS.'''

            list_display = (
                'user',
                # add here the unique fields from ProfileOne!
            )
            readonly_fields = (
                'user',
                'first_name',  # Imported field from User model class! 
                'last_name',  # Imported field from User model class!
                'email',  # Imported field from User model class!
                'sex',  # Imported field from User model class!
                'date_joined',  # Imported field from User model class!
                'last_login',  # Imported field from User model class!
            )
            # exclude = ('xxxx',)
            # List Filter: you cannot call imported fields!
            # list_filter = ('xxx', 'xxx',)  # add here the filterable fields from ProfileOne!
            search_fields = [
                'user', 
                'first_name', 
                'last_name', 
                'email',
                # add here the searchable fields from ProfileOne!
            ]

            # Bringing from User class:
            def first_name(self, obj):
                return obj.user.first_name

            # Bringing from User class:
            def last_name(self, obj):
                return obj.user.last_name

            # Bringing from User class:
            def email(self, obj):
                return obj.user.email

            # Bringing from User class:
            def sex(self, obj):
                return obj.user.sex
            
            # Bringing from User class:
            def date_joined(self, obj):
                return obj.user.date_joined

            # Bringing from User class:
            def last_login(self, obj):
                return obj.user.last_login

            # Remove the delete action from the list-view:
            def get_actions(self, request):
                actions = super().get_actions(request)
                if 'delete_selected' in actions:
                    del actions['delete_selected']
                return actions

            # Prevent deletion of profile from the CMS, except when User is deleted:
            def has_delete_permission(self, request, obj=None):
                if request.path.startswith('/admin/auth/user/'):
                    return True
                return False

            # Prevent the addition of a lone profile accidentally:
            def has_add_permission(self, request):
                return False


        class UserProfileTwoCMS(admin.ModelAdmin):
            '''Defining how the UserProfileTwo Model class will exclusivily be shown on the CMS.'''

            list_display = (
                'user',
                # add here the unique fields from ProfileTwo!
            )
            readonly_fields = (
                'user',
                'first_name',  # Custom field from User class 
                'last_name',  # Custom field from User class
                'email',  # Custom field from User class
                'sex',  # Custom field from User class
                'date_joined',  # Custom field from User class
                'last_login',  # Custom field from User class
            )
            # exclude = ('xxxx',)
            list_filter = (
                'sex',
                # add here the filterable fields from ProfileTwo!
            )
            search_fields = [
                'user', 
                'first_name', 
                'last_name', 
                'email',
                # add here the searchable fields from ProfileTwo!
            ]

            # Bringing from User class:
            def first_name(self, obj):
                return obj.user.first_name

            # Bringing from User class:
            def last_name(self, obj):
                return obj.user.last_name

            # Bringing from User class:
            def email(self, obj):
                return obj.user.email

            # Bringing from User class:
            def sex(self, obj):
                return obj.user.sex
            
            # Bringing from User class:
            def date_joined(self, obj):
                return obj.user.date_joined

            # Bringing from User class:
            def last_login(self, obj):
                return obj.user.last_login

            # Remove the delete action from the list-view:
            def get_actions(self, request):
                actions = super().get_actions(request)
                if 'delete_selected' in actions:
                    del actions['delete_selected']
                return actions

            # Prevent deletion of profile from the CMS, except when User is deleted:
            def has_delete_permission(self, request, obj=None):
                if request.path.startswith('/admin/auth/user/'):
                    return True
                return False

            # Prevent the addition of a lone profile accidentally:
            def has_add_permission(self, request):
                return False
            

        # Registering Django CMS customizations:
        admin.site.register(User, UserCMS)
        # Registering App CMS features:
        admin.site.register(UserProfileOne, UserProfileOneCMS)
        admin.site.register(UserProfileTwo, UserProfileTwoCMS)



    5) OPTIONALS:
    
        5.1) If you need to create your front-end Registration and Profile forms:
            /33-Web-development/general/django/10-login-and-logout/1-registering-custom-form.txt

        5.2) If you need to customize your CMS Accounts > Users (list-view and/or detail-view):
            /33-Web-development/general/django/4-cms-admin/data-from-elsewhere/attr-from-other-class-to-detail-view.py
            /33-Web-development/general/django/4-cms-admin/data-from-elsewhere/attr-from-other-class-to-list-view.py


    6) Migrate and test it:

        $ python manage.py makemigrations accounts
        $ python manage.py migrate
        $ python manage.py runserver

        # Now, try the admin and check if you are seen the User Profile area:
        http://127.0.0.1:8000/admin/


    >> Now, each user created will generate a UserProfile instance connected that will be
        available to read/update/delete.