

EXTENDING THE USER FEATURES WITH PROFILE:

    >> Let's create another model/table in order to isolate extra data associate with each user,
        creating a UserProfile class;

    >> This approach make easier to management user-data that might change drastically if a special
        setting is activated, for example, from personnal account to business one where the data
        associated with the user probably change a lot;


    1) Very basic to use Django built-in user features:
        /33-Web-development/general/django/3-1-backend-models-database/3-users/0-users-setup.txt
        /33-Web-development/general/django/3-1-backend-models-database/3-users/extending-users-basic.txt



    2) In 'accounts' sub-app, open the 'models.py' file:

        from django.db import models
        from django.contrib.auth.models import AbstractUser


        class User(AbstractUser):
            ...


        class UserProfileOne(models.Model):
            id = models.BigAutoField(
                primary_key=True,
                unique=True,
                editable=False,
            )
            user = models.OneToOneField(
                User,
                on_delete=models.CASCADE,  # Tells Django to del the UserProfileOne if the User is deleted.
                related_name=REL_PROFILE_1,
                verbose_name=lng.LB_USER,
            )
            first_name = models.CharField(
                max_length=VAL_PROFILE_1_NAME_MAXLNGH,
                blank=True,
                verbose_name=lng.LB_PROFILE_1_FNAME,
                error_messages={
                    'max_length': lng.TX_ERRO_PROFILE_1_FNAME_MAXLNGH
                    % {
                        'txt': lng.LB_PROFILE_1_FNAME,
                        'val': VAL_PROFILE_1_NAME_MAXLNGH,
                    },
                },
            )
            last_name = models.CharField(
                max_length=VAL_PROFILE_1_NAME_MAXLNGH,
                blank=True,
                verbose_name=lng.LB_PROFILE_1_LNAME,
                error_messages={
                    'max_length': lng.TX_ERRO_PROFILE_1_LNAME_MAXLNGH
                    % {
                        'txt': lng.LB_PROFILE_1_LNAME,
                        'val': VAL_PROFILE_1_NAME_MAXLNGH,
                    }
                },
            )
            sex = models.CharField(
                max_length=20,
                choices=CHOICES_SEX,
                null=True,
                blank=False,
                verbose_name=lng.LB_PROFILE_1_SEX,
                help_text=lng.TX_HELP_PROFILE_1_SEX % {'txt': BRAND_NAME},
                error_messages={
                    'blank': lng.TX_ERRO_PROFILE_1_SEX_BLNK % {'txt': lng.LB_PROFILE_1_SEX},
                },
            )
            birthdate = models.DateField(
                null=True,
                blank=True,
                verbose_name=lng.LB_PROFILE_1_BIRTHDATE,
                error_messages={
                    'invalid': lng.TX_ERRO_PROFILE_1_BIRTH_INVLD,
                },
            )
            birth_year = models.CharField(
                max_length=4,
                null=True,
                blank=True,
                verbose_name=lng.LB_PROFILE_1_BIRTH_YEAR,
            )
            country = models.ForeignKey(
                Country,
                on_delete=models.SET_NULL,
                null=True,
                blank=False,
                verbose_name=lng.LB_PROFILE_1_COUNTRY,
                help_text=lng.TX_HELP_PROFILE_1_COUNTRY,
                error_messages={
                    'blank': lng.TX_ERRO_PROFILE_1_COUNTRY_BLNK % {'txt': lng.LB_PROFILE_1_COUNTRY}
                },
            )
            city = models.CharField(
                max_length=40,
                null=True,
                blank=True,
                verbose_name=lng.LB_PROFILE_1_CITY,
                help_text=lng.TX_HELP_PROFILE_1_CITY,
            )
            updated_at = models.DateTimeField(
                auto_now=True,
                blank=True,
                verbose_name=lng.LB_UPDATED_AT,
            )
            updated_by = models.ForeignKey(
                User,
                related_name='updated_profiles_1',
                on_delete=models.SET_NULL,  # if the user-updater is deleted, the updated_by field is null.
                null=True,
                verbose_name=lng.LB_UPDATED_BY,
                help_text=lng.TX_HELP_UPDATED_BY,
            )

            class Meta:
                db_table = 'user_profile_one'
                ordering = ['user', '-updated_at']
                verbose_name = 'Profile, Personal'
                verbose_name_plural = 'Profiles, Personal'

            def __str__(self):
                if self.user:
                    if self.first_name and self.last_name:
                        return f'{self.user.username} ({self.first_name} {self.last_name})'
                    return self.user.username
                return lng.CMS_ERRO_PROFILE

            def clean(self):
                '''It's a built-in method for adding custom validation logic before saving data to the db.'''
                validate_birth(self.birthdate)

            def save(self, *args, **kwargs):
                if self.first_name:
                    self.first_name = self.first_name.title()
                if self.last_name:
                    self.last_name = self.last_name.title()
                if self.city:
                    self.city = self.city.title()
                # Defining the user's birth year automatically:
                if self.birthdate:
                    self.birth_year = str(self.birthdate)[:4]
                # Checking the updated_by:
                # Important: this need to be checked in admin.py and views.py as well!
                user = kwargs.pop('user', None)
                if user and user.is_authenticated and self.updated_by != user:
                    self.updated_by = user
                super().save(*args, **kwargs)


        class UserProfileTwo(models.Model):
            id = models.BigAutoField(
                primary_key=True,
                unique=True,
                editable=False,
            )
            user = models.OneToOneField(
                User,
                on_delete=models.CASCADE,  # Tells Django to del the UserProfileTwo if the User is deleted.
                related_name=REL_PROFILE_2,
                verbose_name=lng.LB_USER,
            )
            business_name = models.CharField(
                max_length=VAL_PROFILE_2_BNAME_MAXLNGH,
                # unique=True,  # Commercial name must be flexible! Legal name, not!
                null=False,
                blank=False,
                verbose_name=lng.LB_PROFILE_2_BNAME,
                help_text=lng.TX_HELP_PROFILE_2_BNAME,
                error_messages={
                    'blank': lng.TX_ERRO_PROFILE_2_BNAME_BLNK % {'txt': lng.LB_PROFILE_2_BNAME},
                    # 'unique': 'This business name already exists.'
                    'max_length': lng.TX_ERRO_PROFILE_2_BNAME_MAXLNGH
                    % {
                        'txt': lng.LB_PROFILE_2_BNAME,
                        'val': VAL_PROFILE_2_BNAME_MAXLNGH,
                    },
                },
            )
            legal_name = models.CharField(
                max_length=VAL_PROFILE_2_LEGAL_MAXLNGH,
                unique=True,
                null=True,
                blank=False,
                verbose_name=lng.LB_PROFILE_2_LEGAL,
                help_text=lng.TX_HELP_PROFILE_2_LEGAL,
                error_messages={
                    'blank': lng.TX_ERRO_PROFILE_2_LEGAL_BLNK % {'txt': lng.LB_PROFILE_2_LEGAL},
                    'unique': lng.TX_ERRO_PROFILE_2_LEGAL_UNIQ,
                    'max_length': lng.TX_ERRO_PROFILE_2_LEGAL_MAXLNGH
                    % {
                        'txt': lng.LB_PROFILE_2_LEGAL,
                        'val': VAL_PROFILE_2_LEGAL_MAXLNGH,
                    },
                },
            )
            country_business = models.ForeignKey(
                Country,
                on_delete=models.SET_NULL,
                null=True,
                blank=False,
                verbose_name=lng.LB_PROFILE_2_COUNTRY,
                help_text=lng.TX_HELP_PROFILE_2_COUNTRY,
                error_messages={
                    'blank': lng.TX_ERRO_PROFILE_1_COUNTRY_BLNK,
                },
            )
            city_business = models.CharField(
                max_length=VAL_PROFILE_2_CITY_MAXLNGH,
                null=True,
                blank=False,
                verbose_name=lng.LB_PROFILE_2_CITY,
                help_text=lng.TX_HELP_PROFILE_2_CITY,
                error_messages={
                    'blank': lng.TX_ERRO_PROFILE_2_CITY_BLNK % {'txt': lng.LB_PROFILE_2_CITY},
                    'max_length': lng.TX_ERRO_PROFILE_2_CITY_MAXLNGH
                    % {
                        'txt': lng.LB_PROFILE_2_CITY,
                        'val': VAL_PROFILE_2_CITY_MAXLNGH,
                    },
                },
            )
            description = models.TextField(
                max_length=VAL_PROFILE_2_DESC_MAXLNGH,
                null=True,
                blank=False,
                verbose_name=lng.LB_PROFILE_2_DESC,
                help_text=lng.TX_HELP_PROFILE_2_DESC,
                error_messages={
                    'blank': lng.TX_ERRO_PROFILE_2_DESC_BLNK % {'txt': lng.LB_PROFILE_2_DESC},
                    'max_length': lng.TX_ERRO_PROFILE_2_DESC_MAXLNGH
                    % {
                        'txt': lng.LB_PROFILE_2_DESC,
                        'val': VAL_PROFILE_2_DESC_MAXLNGH,
                    },
                },
            )
            business_url = models.URLField(
                blank=True,
                verbose_name=lng.LB_PROFILE_2_URL,
            )
            social_media = models.URLField(
                blank=True,
                verbose_name=lng.LB_PROFILE_2_URL_SOCIAL,
            )
            business_email = models.EmailField(
                null=True,
                blank=False,
                verbose_name=lng.LB_PROFILE_2_EMAIL,
                error_messages={
                    'blank': lng.TX_ERRO_PROFILE_2_EMAIL_BLNK % {'txt': lng.LB_PROFILE_2_EMAIL},
                    'invalid': lng.TX_ERRO_PROFILE_2_EMAIL_INVLD,
                },
            )
            contact_first_name = models.CharField(
                max_length=20,
                blank=True,
                verbose_name=lng.LB_PROFILE_2_FNAME,
            )
            contact_last_name = models.CharField(
                max_length=20,
                blank=True,
                verbose_name=lng.LB_PROFILE_2_LNAME,
            )
            updated_at = models.DateTimeField(
                auto_now=True,
                blank=True,
                verbose_name=lng.LB_UPDATED_AT,
            )
            updated_by = models.ForeignKey(
                User,
                related_name='updated_profiles_2',
                on_delete=models.SET_NULL,  # if the user-updater is deleted, the updated_by field is null.
                null=True,
                verbose_name=lng.LB_UPDATED_BY,
                help_text=lng.TX_HELP_UPDATED_BY,
            )

            class Meta:
                db_table = 'user_profile_two'
                ordering = ['user', '-updated_at']
                verbose_name = 'Profile, Business'
                verbose_name_plural = 'Profiles, Business'

            def __str__(self):
                if self.user:
                    if self.business_name:
                        return f'{self.business_name} ({self.user.username})'
                    return self.user.username
                return lng.CMS_ERRO_PROFILE

            def clean(self):
                '''It's a built-in method for adding custom validation logic before saving data to the db.'''
                pass

            def save(self, *args, **kwargs):
                if self.business_name:
                    self.business_name = self.business_name.title()
                if self.legal_name:
                    self.legal_name = self.legal_name.upper()
                if self.contact_first_name:
                    self.contact_first_name = self.contact_first_name.title()
                if self.contact_last_name:
                    self.contact_last_name = self.contact_last_name.title()
                if self.city_business:
                    self.city_business = self.city_business.title()
                # Checking the updated_by:
                # Important: this need to be checked in admin.py and views.py as well!
                user = kwargs.pop('user', None)
                if user and user.is_authenticated and self.updated_by != user:
                    self.updated_by = user
                super().save(*args, **kwargs)

        

    3) Create the signal to create a linked UserProfile entry automatically when a new user is
        created via front-end or Django CMS:

        /33-Web-development/general/django/7-middlewares-and-signals/signals/signals-user-extended.txt



    
    4) Open the accounts 'admin.py' file, and:

        from django.contrib import admin
        from django.contrib.auth.admin import UserAdmin
        from .forms import CustomUserCreationForm
        from django.utils.html import format_html
        from django.urls import reverse
        from config_folder.constants import (
            REL_PROFILE_1,
            REL_PROFILE_2,
            PATH_CMS_USERS,
        )
        from .models import (
            User,
            UserProfileOne,
            UserProfileTwo,
        )
        from config_folder.language import (
            TX_PROFILE_1,
            TX_PROFILE_2,
            CMS_MORE_DETAILS,
            CMS_ERRO_PROFILE,
        )


        @admin.register(User)
        class UserCMS(UserAdmin):
            '''Defining how the User Model class will exclusivily be shown on the CMS.'''

            # Specify the custom form for creating users
            add_form = CustomUserCreationForm

            list_display = (
                'username',
                'email',
                'last_login',
                'is_staff',
                # List_display accept imported fields using prefix and imported method (prefix recommended):
                # Reserved space...
            )
            # All fields exclusivily for the CMS Adding New User:
            add_fieldsets = (
                (
                    None,
                    {
                        'classes': ('wide',),
                        'fields': (
                            'profile_type',
                            'username',
                            'email',
                            'password1',
                            'password2',
                            'accepted_min_age',
                            'accepted_our_privacy',
                        ),
                    },
                ),
            )
            # All fields exclusivily for the CMS Visualizing a User:
            fieldsets = (
                (
                    None,
                    {
                        'fields': (
                            'username',
                            'password',
                            'profile_type',
                            'profile_link',  # Adding the UserProfile link in the User Detail-view!
                        )
                    },
                ),
                (
                    'Personal info',
                    {
                        'fields': (
                            'email',
                            'language',
                        )
                    },
                ),
                (
                    'Permissions',
                    {
                        'fields': (
                            'is_active',
                            'is_notified_by_email',
                            'is_staff',
                            'is_superuser',
                            'groups',
                            'user_permissions',
                        )
                    },
                ),
                (
                    'Important dates',
                    {
                        'fields': (
                            'date_joined',
                            'last_login',
                            'updated_at',
                            'updated_by',
                        )
                    },
                ),
            )
            list_filter = (
                'profile_type',
                'language',
                'is_notified_by_email',
                'is_active',
                'is_staff',
                'is_superuser',
                # List_filter only accepts imported fields using prefix:
                # Important: Don't call UserProfile's content here in this case!
            )
            search_fields = [
                'username',
                'email',
                'date_joined',
                # Search_fields accept imported fields using prefix and imported method (prefix recommended):
                'userprofileone__first_name',
                'userprofileone__last_name',
                'userprofileone__birth_year',
                'userprofileone__city',
                'userprofileone__country',
                'userprofiletwo__contact_first_name',
                'userprofiletwo__contact_last_name',
                'userprofiletwo__business_email',
                'userprofiletwo__city_business',
                'userprofiletwo__country_business',
            ]
            readonly_fields = (
                # 'profile_type',  # Dynamicaly included!
                # 'username',  # Dynamicaly included!
                # 'accepted_min_age',  # Dynamicaly included!
                # 'accepted_our_privacy',  # Dynamicaly included!
                'profile_link',  # Important: don't remove 'profile_link' from here!
                'date_joined',
                'last_login',
                'updated_at',
                'updated_by',
                # Readonly_fields only accept imported method, never with prefix:
                # Important: Don't call UserProfile's content here in this case!
            )

            # Create a hyperlink to the associated UserProfile to be used on the list-view and detail-view:
            def profile_link(self, obj):
                if obj.profile_type == '1' and hasattr(obj, REL_PROFILE_1):
                    url = reverse(
                        # Automatic admin-view creation structure: 'admin:app_label_modelname_change':
                        'admin:accounts_userprofileone_change',
                        args=[getattr(obj, REL_PROFILE_1).id],
                    )
                    return format_html("<a href='{}'>{} ({})</a>", url, TX_PROFILE_1, CMS_MORE_DETAILS)
                elif obj.profile_type == '2' and hasattr(obj, REL_PROFILE_2):
                    url = reverse(
                        'admin:accounts_userprofiletwo_change',
                        args=[getattr(obj, REL_PROFILE_2).id],
                    )
                    return format_html("<a href='{}'>{} ({})</a>", url, TX_PROFILE_2, CMS_MORE_DETAILS)
                return CMS_ERRO_PROFILE

            profile_link.short_description = 'User Profile'

            def get_readonly_fields(self, request, obj=None):
                """Built-in method to extend the 'readonly_fields' power."""
                if obj:
                    # If the user exists (obj), make some fields field read-only on detail-view,
                    # but still editable on the CMS Add User form:
                    return self.readonly_fields + (
                        'profile_type',
                        'username',
                        'accepted_min_age',
                        'accepted_our_privacy',
                    )  # type: ignore
                return self.readonly_fields

            def save_model(self, request, obj, form, change):
                # Checks to save the current user as updated_by:
                cms_user = request.user
                if change and cms_user != obj.updated_by:
                    obj.updated_by = cms_user
                super().save_model(request, obj, form, change)


        @admin.register(UserProfileOne)
        class UserProfileOneCMS(admin.ModelAdmin):
            '''Defining how the UserProfileOne Model class (personal) will exclusivily be shown on the CMS.'''

            list_display = (
                'user',
                'sex',
                'birth_year',
                'country',
                # List_display accept imported fields using prefix and imported method (prefix recommended):
                'user__last_login',
            )
            exclude = ('birth_year',)
            list_filter = (
                'sex',
                'country',
                'is_nomad',
                # List_filter only accepts imported fields using prefix:
                'user__language',
            )
            search_fields = [
                'user',
                'city',
                'first_name',
                'last_name',
                'birth_year',
                # Search_fields accept imported fields using prefix and imported method (prefix recommended):
                'user__email',
            ]
            readonly_fields = (
                'user',
                'updated_at',
                'updated_by',
                # Readonly_fields only accept imported method, never with prefix:
                'email',  # Imported from User
                'is_notified_by_email',  # Imported from User
                'language',  # Imported from User
                'last_login',  # Imported from User
                'date_joined',  # Imported from User
            )

            # Importing field from User model class:
            def email(self, obj):
                return obj.user.email

            def is_notified_by_email(self, obj):
                return obj.user.is_notified_by_email

            def language(self, obj):
                return obj.user.language

            def last_login(self, obj):
                return obj.user.last_login

            def date_joined(self, obj):
                return obj.user.date_joined

            def get_actions(self, request):
                '''This built-in method can conditionally enable or disable CMS actions, returning
                a dictionary of actions allowed.'''
                # Remove the delete action from the list-view:
                actions = super().get_actions(request)
                if 'delete_selected' in actions:
                    del actions['delete_selected']
                return actions

            def has_delete_permission(self, request, obj=None):
                '''This built-in method should return True if deleting obj is permitted.'''
                # Prevent deletion of profile from the CMS, except when User is deleted:
                if request.path.startswith(PATH_CMS_USERS):
                    return True
                return False

            def has_add_permission(self, request):
                '''This built-in method should return True if adding an object is permitted.'''
                # Prevent the addition of a lone profile accidentally:
                return False

            def save_model(self, request, obj, form, change):
                # Checks to save the current user as updated_by:
                cms_user = request.user
                if change and cms_user != obj.updated_by:
                    obj.updated_by = cms_user
                super().save_model(request, obj, form, change)


        @admin.register(UserProfileTwo)
        class UserProfileTwoCMS(admin.ModelAdmin):
            '''Defining how the UserProfileTwo Model class (business) will exclusivily be shown on the CMS.'''

            list_display = (
                'user',
                'business_name',
                'country_business',
                # List_display accept imported fields using prefix and imported method (prefix recommended):
                'user__last_login',
            )
            # exclude = ('', '',)
            list_filter = (
                'country_business',
                # List_filter only accepts imported fields using prefix:
                'user__language',
            )
            search_fields = [
                'user',
                'description',
                'city_business',
                'contact_first_name',
                'contact_last_name',
                'business_email',
                'date_joined',
                # Search_fields accept imported fields using prefix and imported method (prefix recommended):
                'user__email',
            ]
            readonly_fields = (
                'user',
                'updated_at',
                'updated_by',
                # Readonly_fields only accept imported method, never with prefix:
                'email',  # Imported from User
                'is_notified_by_email',  # Imported from User
                'language',  # Imported from User
                'last_login',  # Imported from User
                'date_joined',  # Imported from User
            )

            def email(self, obj):
                return obj.user.email

            def is_notified_by_email(self, obj):
                return obj.user.is_notified_by_email

            def language(self, obj):
                return obj.user.language

            def last_login(self, obj):
                return obj.user.last_login

            def date_joined(self, obj):
                return obj.user.date_joined

            def get_actions(self, request):
                '''This built-in method can conditionally enable or disable CMS actions, returning
                a dictionary of actions allowed.'''
                # Remove the delete action from the list-view:
                actions = super().get_actions(request)
                if 'delete_selected' in actions:
                    del actions['delete_selected']
                return actions

            def has_delete_permission(self, request, obj=None):
                '''This built-in method should return True if deleting obj is permitted.'''
                # Prevent deletion of profile from the CMS, except when User is deleted:
                if request.path.startswith(PATH_CMS_USERS):
                    return True
                return False

            def has_add_permission(self, request):
                '''This built-in method should return True if adding an object is permitted.'''
                # Prevent the addition of a lone profile accidentally:
                return False

            def save_model(self, request, obj, form, change):
                # Checks to save the current user as updated_by:
                cms_user = request.user
                if change and cms_user != obj.updated_by:
                    obj.updated_by = cms_user
                super().save_model(request, obj, form, change)


        # Registering Django CMS customizations:
        # Reserved space...



    5) Registration and Profile forms (templates):
        /33-Web-development/general/django/10-login-and-logout/1-registering-custom-form.txt


    6) Adding the Change Password option:

    
        X) /accounts/views.py:

            from django.contrib.auth.views import PasswordChangeView

            ...

            class CustomPasswordChangeView(PasswordChangeView):
                template_name = 'accounts/pwd_change.html'

                def form_valid(self, form):
                    messages.success(self.request, 'Your password was changed successfully.')
                    return redirect('accounts:profile_view', username=self.request.user.username)  # type: ignore

                def get_context_data(self, **kwargs):
                    # Definitions:
                    context = super().get_context_data(**kwargs)
                    # Building context:
                    context['page_title'] = f'Changing Password: {self.request.user.username}'  # type: ignore
                    context['bt_back'] = 'Back'
                    context['bt_submit'] = 'Change my password'
                    return context

        X) /accounts/urls.py:

            from accounts.views import CustomPasswordChangeView

            urlpatterns = [
                ...
                # http://127.0.0.1:8000/accounts/aldolammel/pwd/
                path('pwd/', CustomPasswordChangeView.as_view(), name='pwd_change_view'),
            ]

        X) /accounts/templates/accounts/pwd_change.html:

            /33-Web-development/general/django/9-forms/frontend-user-change-password.html





    XX) If you need to customize your CMS Accounts > Users (list-view and/or detail-view):
        /33-Web-development/general/django/4-cms-admin/data-from-elsewhere/attr-from-other-class-to-detail-view.py
        /33-Web-development/general/django/4-cms-admin/data-from-elsewhere/attr-from-other-class-to-list-view.py



    X) Migrate and test it:

        $ python manage.py makemigrations accounts
        $ python manage.py migrate
        $ python manage.py runserver

        # Now, try the admin and check if you are seen the User Profile area:
        http://127.0.0.1:8000/admin/


    >> Now, each user created will generate a UserProfile instance connected that will be
        available to read/update/delete.